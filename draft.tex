\title{Survivable Set Connectivity}
\author{
 by Fermi Ma and Erik Waingarten
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{graphicx}

\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

\begin{document}
\maketitle

\section{Introduction}

In this paper, we analyze the problem of Survivable Set Connectivity (SSC), a generalization of the classical Set Connectivity problem. Set connectivity is formulated as:
\begin{quote}
\textbf{Input}: A graph weighted $G = (V, E)$, $c: E \rightarrow \mathbb{R}$ and a collection of sets $(S_i, T_i)$. \\
\textbf{Output}: A minimum cost subgraph $H \subset G$ such that there is a path between $S_i$ and $T_i$ for each $i$. 
\end{quote}
In SSC, the problem is modified so that each pair of sets $(S_i,T_i)$ must be connected by $k_i$ paths, instead of just 1. More formally, the problem is:

\begin{quote}
\textbf{Input}: A graph weighted $G = (V, E)$, $c: E \rightarrow \mathbb{R}$ and a collection of sets $(S_i, T_i)$, along with a value $k$. \\
\textbf{Output}: A minimum cost subgraph $H \subset G$ such that there are $k$ edge-disjoint paths between $S_i$ and $T_i$ for each $i$. 
\end{quote}

Note that this problem generalizes the common connectivity problems. The question of whether there are $k$ connections between $s$ and $t$ sets only one pair $(S_1, T_1)$ where $S_1 = \{ s \}$ and $T_i = \{ t \}$. 

[ GIVE MORE EXAMPLES HERE ]

As with many of these kinds of problems, SSC is $\mathsf{NP}$-hard. The common route taken in 6.856 has been to find polynomial time algorithms for approximations; however, in the case with SSC, it is $\mathsf{NP}$-hard to achieve a polylogarithmic approximation. 

Another possible approach is therefore to relax the question. Instead of requiring at least $k$ edge-disjoint paths, we will allow some sets to have less than $k$ paths, but not too much less. We will present an approximation algorithm which outputs a subgraph of cost $O(polylog(n))$ times the optimum such that for each $(S_i, T_i)$ pairs, there are at least $\Omega(\frac{k}{\log n})$ edge-disjoint paths between $S_i$ and $T_i$. 

The approximation algorithm will follow the usual approach to approximation algorithms of this kind. We will first write the problem as an integer linear program, we solve the linear programming relaxation, and then we round the solution. 

The analysis will be slightly different from the analysis shown in class. Usually, our randomized algorithm will return a feasible solution to the problem, and our analysis work is mostly to bound the cost. This was the case with max-sat, set-cover, and multi-commodity flows. In our case, we will show that the rounded solution will be close to the optimal, but we will work to show that the rounded solution is feasible. 

\section{Linear Programming Formulation}

We can formulate a cut-based integer linear program for SSC. For each edge, we have the variable $x_e$ defined as
\begin{align}
 x_e &= \left\{ \begin{array}{cc} 1 & e \in H \\
                                  0 & \text{ otherwise. } \end{array} \right.
\end{align}
$H$ will be the subgraph consisting of edges $e$ where $x_e = 1$. \\ \\
SSC-LP:
\begin{align}
\min & \sum c(x) x_e  \\
\text{ s.t } & \sum_{e \in \delta(S)} x_e \geq k, \text{ where } S_i \subset S, T_i \subset V - S, \delta(S) \text{ is the edges of the $S$ cut }
\end{align}
This cut-based integer linear program finds exactly $H$. To see why the constraints ensure that each $(S_i, T_i)$ pair has at least $k$ edge disjoint paths, we can look at the cuts corresponding to $S_i$ and $T_i$. First, we let $S = S_i$, then there are $k$ outgoing edges. We can choose to include one more node to $S$, following a particular outgoing edge of the cut in $H$. We can continue doing this until we reach $T_i$. This will trace out a path between $S_i$ and $T_i$. If we do this for each edge, and then we do this for each $(S_i, T_i)$ pair, we can confirm that there are in fact $k$ edge-disjoint paths between each $(S_i, T_i)$ pair. 

There is one caveat that has not been addressed. We have exponentially many constraints! Since there can be exponentially many set $S$ with $S_i \subset S$ and $T_i \subset V - S$. We solve this with a similar idea to semi-definite programming, by giving a separation oracle which runs in polynomial time. 

The separation oracle will just compute the minimum $S_i, T_i$ cut in the graph. What we can do is contract $S_i$ and $T_i$ to single edges, and then compute the min-cut in the remaining graph. If there is a min-cut of size less than $k$, then that cut will correspond to a violating contraint. If the min-cut has size at least $k$, then all cuts have size at least $k$, so we have satisfied the constraints.

The linear programming relaxation to the above program will be the first step of the algorithm. The remaining work will be rounding the fractional solution to an integral solution and satisfy the constraints. 

\section{Tree Embeddings}

The next tool we will need are tree embeddings. We have seen metric embeddings in class. Basically, we had a desired type of object $O$ (in the case of cuts, we had a metric space corresponding to a cut) what we did was come up with a metric space $(X, d)$ and a map $f: (X, d) \rightarrow O$ such that the map satisfied certain properties on the distances. 

Here we will have a similar goal. We want to understand minimum cost weighted graphs, but since analyzing them is hard, we instead study minimum cost weighted trees, and then we map the trees back to the graphs. 

\begin{definition}
A tree embedding of a weighted graph $G = (V, E)$ will be a tree $T = (V_T, E_T)$ with weights $y: E \rightarrow \mathbb{R}$ and a function $\text{map} : V_T \cup E_t \rightarrow V \cup P(E)$ ($P(E)$ is the power set of $E$) such that
\begin{align}
\text{map}(V_t) &\subset V \\
\text{map}(E_t) &\subset E
\end{align}
In other words, vertices map to vertices and edges map to edges. We will usually refer to an embedding as $(T, y, \text{map})$. 
\end{definition}

\subsection{Racke Tree Black Box}

We will use a particular type of tree embedding which will allow us to paths in the tree to paths in the graph. 

\begin{definition}
For a given graph $G = (V, E)$, a Racke Tree is a tree embedding of $G$, $(T, y, \text{map})$ such that:
\begin{enumerate}
\item $\text{map}$ restricted to the leafs of $T$ is a bijection with the vertices of $G$.
\item For each edge $e \in E_t$ joining $u$ and $v$, $\text{map}(e)$ is a path joining nodes $\text{map}(u)$ and $\text{map}(v)$.
\item For some edge $e \in E_t$, $y_e$ (the cost of the edge) is a special quantity. Removing $y_e$ cuts the tree into two components, and so the leaves in the two components form a cut $\delta(S)$. Figure~\ref{fig:rackecut} gives an example for one such cut induced by an edge.
\begin{align}
y_e &= \sum_{e' \in \delta(S)} x_e
\end{align}
\end{enumerate}
\end{definition}

\begin{figure}
\centering
\label{fig:rackecut}
\includegraphics[width=0.5\linewidth]{Rackecut.pdf}
\caption{Racke tree cut induced by an edge in the tree.}
\end{figure}

Having made these definition, we can refer to the inverse $\text{map}^{-1}$ in the obvious manner. $\text{map}^{-1}$ on a vertex will map to the corresponding leaf, and $\text{map}^{-1}$ on an edge in the graph will map to all edges in the tree whose paths contain that edge. 

\begin{definition}
Given a Racke tree, the load on an edge of the graph $e \in E$ is
\begin{align}
load(e) &= \sum_{f \in \text{map}^{-1}} y_f
\end{align}
The relative load, $rload(e) = \dfrac{load(e)}{x_e}$. 
\end{definition}

Figure~\ref{fig:racketree} gives an example of a Racke tree with the mapping. Each red vertex of the tree is mapped to another red vertex on the graph, and the edge between them corresponds to a path between the red vertices. This gives us a simple way to map flows from Racke trees to the graph and vice-versa. 

In particular, if we have a multicommodity flow $\{ f_i \}$ on the graph, then we can easily map into a multicommodity flow on the Racke tree. If there is a flow $f_i$ from $s_i$ to $t_i$, then we find leaves $s_i^{T}=\text{map}^{-1}(s_i)$ and $t_i^T\text{map}^{-1}(t_i)$ and route $f_i$ units of flow through the unique path from $s_i$ to $t_i$.

For obtaining a flow on the graph given one on the Racke tree, if $f_i^T(e)$ is the flow of commodity $i$ on the tree on $e \in E_t$, then we route $f_i^T(e)$ units of flow down the path given by $\text{map}(e)$.   

\begin{figure}
\label{fig:racketree}
\centering
\includegraphics[width=\linewidth]{Rackeembeddinggraph.pdf}
\caption{Example Racke Tree where red nodes are mapped and edge maps to a path.}
\end{figure}

There are some crucial properties of Racke trees which we will treat as black boxes. We will define these as lemmas without proof, and we refer to [CITE] for the proofs.

\begin{lemma}
If we have a graph $G = (V, E)$ and capacities $x: E \rightarrow \mathbb{R}$ and a Racke tree $(T, y, \text{map})$. A multicommodity flow on $G$, $\{ f_i \}$, maps directly to a multicommodity flow on the tree which is also feasible. Likewise, a multicommodity flow on $T$ maps directly into a multicommodity flow on the graph, with the small caveat that we must multiply the capacity of the edge by the relative load. 
\end{lemma}

[ EXPLAIN HOW TO MAP FLOWS ]

\begin{lemma}
For some given graph $G = (V, E)$ and capacities $x: E \rightarrow \mathbb{R}$, we can sample efficiently from Racke trees of $G$, such that 
\begin{align}
\max_{e \in E} \textbf{E}[rload(e)] &\leq \alpha = O(\log n) 
\end{align}
\end{lemma}

\begin{lemma}
The height of the trees sampled is $O(\log nC)$, where $C$ is the ratio of the largest to smallest capacity in $G$. In our cases, the height will always be $O(\log n)$. 
\end{lemma}

\subsection{RoundGKR Black Box}

\section{Algorithm}

\subsection{Analysis}

\section{Conclusion}

\subsection{Open Problems}

\end{document}